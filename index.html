<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The cool corner</title>
    <style>
        /* Basic styling to make the canvas fill the page */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: #fff;
        }
        canvas {
            display: block;
        }
		
		#info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
            padding: 10px;
            background-color: rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>

    <!-- We'll draw our scene on this canvas -->
    <canvas id="webgl-canvas"></canvas>
	
	<div id="info">
        Loading your awesome experience. <br/>
        <div id="info-percent"> </div>
    </div>

    <!-- Import maps are a modern way to manage JavaScript modules in the browser -->
    <!-- This tells the browser where to find the 'three' and 'three/addons/' modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- Our main application logic -->
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        let pointer = new THREE.Vector2();
        let scene, renderer, controls, raycaster, canvas;

        
        let SCREEN_WIDTH = window.innerWidth;
        let SCREEN_HEIGHT = window.innerHeight;
        let aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
        const frustumSize = 7;
        const defaultCamPos = new THREE.Vector3(3.5, -1.3, 10);
        let minScroll = -20;
        let maxScroll = 0;
        let mixer, clock;
        const scrollSpeed = 0.01;
        const smoothingFactor = 0.1;
        let targetCameraY = defaultCamPos.y;
        let clickableElements = {};
        let hoverableElements = {};

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let freeLookAllowed = false;
        let freeMoveAllowed = false;

        let darkModeEnabled = false;
        let darkModeEnableAnimation, darkModeDisableAnimation, artemTalkAnimation;
        let explodeAnimations = [];
        let pointerLantern;

        let eyes;

        let headClicks = 0;

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        const spotLightIntensity = 500;
        const ambientLightIntensity = 0.55;
        const pointerLanternIntensity = 1000;

        let camera, activeCamera,  perspectiveCamera;


        init();

        function init() {
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a); 

            raycaster = new THREE.Raycaster();

            camera = new THREE.OrthographicCamera(frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 0.1, 20009 );
            console.log(frustumSize * aspect / - 2, frustumSize / 2)
            camera.position.copy(defaultCamPos); 
            camera.lookAt(defaultCamPos.sub(new THREE.Vector3(0, 0, defaultCamPos.z)));
            scene.add(camera);

            perspectiveCamera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
            camera.add(perspectiveCamera)
            
            activeCamera = camera;

            canvas = document.getElementById('webgl-canvas');
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.shadowMap.enabled = true;
            renderer.physicallyCorrectLights = true;


            // Ambient light: Illuminates all objects in the scene equally.
            const ambientLight = new THREE.AmbientLight(0xffffff, ambientLightIntensity);
            scene.add(ambientLight);

            let spotLight;

            pointerLantern = new THREE.PointLight(0xefc070, 0, 10, 3);
            pointerLantern.position.setZ(8);
            pointerLantern.castShadow = false;
            pointerLantern.shadow.bias = -0.01;
            scene.add(pointerLantern);

            // Instantiate a loader
            const loader = new GLTFLoader();

            clock = new THREE.Clock();

            
            controls = new PointerLockControls( camera, document.body );
            
            controls.addEventListener( 'lock', function () {

            } );

            controls.addEventListener( 'unlock', function () {

            } );

            // URL of the GLB model to load
            // This is a free model provided by the Khronos Group (creators of GLTF)
            const modelURL = "website.glb";

            loader.load(
                // resource URL
                modelURL,
                // onLoad callback: executed when the resource is loaded
                function (gltf) {
                    // The loaded data is a 'gltf' object which contains the scene, animations, etc.
                    console.log('Model loaded successfully!', gltf);
                    scene.add(gltf.scene);
                    console.log(gltf.animations);

                    mixer = new THREE.AnimationMixer( gltf.scene );
                    var spinnyAction = mixer.clipAction(THREE.AnimationClip.findByName(gltf.animations, 'SpinnyTextCompiledAction'));
                    spinnyAction = spinnyAction.reset();
                    spinnyAction.play();

                    darkModeEnableAnimation = mixer.clipAction(THREE.AnimationClip.findByName(gltf.animations, 'Button_Darkmode_Enable'));
                    darkModeEnableAnimation.setLoop(THREE.LoopOnce);
                    darkModeEnableAnimation.clampWhenFinished = true;
                    

                    darkModeDisableAnimation = mixer.clipAction(THREE.AnimationClip.findByName(gltf.animations, 'Button_Darkmode_Disable'));
                    darkModeDisableAnimation.setLoop(THREE.LoopOnce);
                    darkModeDisableAnimation.clampWhenFinished = true;
                    darkModeDisableAnimation.reset();
                    darkModeEnableAnimation.reset();

                    artemTalkAnimation = mixer.clipAction(THREE.AnimationClip.findByName(gltf.animations, 'ArtemTalkLoop'));
                    artemTalkAnimation.repetitions = 3;
                    artemTalkAnimation.reset();
                    artemTalkAnimation.play();

                    for (let i = 1; i < 5; i++) {
                        var tmpExplode = mixer.clipAction(THREE.AnimationClip.findByName(gltf.animations, `Explode${i}`));
                        tmpExplode.setLoop(THREE.LoopOnce);
                        tmpExplode.clampWhenFinished = true;
                        explodeAnimations.push(tmpExplode);
                    }

                    const objectsToAnchor = [];
                    const objectsToReposition = [];
                    gltf.scene.traverse((object) => { 
                        console.log(object);
                        if (object.isMesh) {
                            object.castShadow = true;     
                            object.receiveShadow = true;
                        }
                        // Objects adjusted for screen resolution
                        if (object.name.slice(-2) === "FL") {
                            objectsToReposition.push(object)
                        }

                        // Objects anchored to camera
                        if (object.name === 'Header' ||
                            object.name === "Face_Frame_FL" ||
                            object.name === "CamSpotLight"
                        ) {
                            console.log(object.name, " anchored");
                            objectsToAnchor.push(object);
                        } else {
                        }

                        if (object.name === "CamSpotLight") {
                            object.castShadow = true;
                            object.shadow.bias = -0.002;
                            object.intensity = spotLightIntensity;
                            object.angle = 0.7;
                            object.penumbra = 0;
                            spotLight = object;

                        }

                        // Clickable Objects. Maybe do like a hashmap to determine this, but doesnt matter
                        if (object.name === 'Button_FL') {
                            clickableElements[object.name] = () => {
                                scene.getObjectByName( "Face_Frame_FL" ).position.setX(scene.getObjectByName( "Face_Frame_FL" ).position.x - 0.05);
                            }
                        }

                        else if (object.name === "Artem_Head_Mesh") {
                            clickableElements[object.name] = () => {
                                headClicks += 1;
                                if (headClicks === 10) {
                                    let head = scene.getObjectByName( "BakedHead" );
                                    head.position.set(0, 0, 0);
                                    object.add(head);
                                    scene.attach(head);
                                    head.scale.set(1, 1, 1);
                                    for (const anim of explodeAnimations) {
                                        anim.play();
                                    }
                                    object.visible = false;
                                }
                            }
                        }

                        else if (object.name === 'Button_CamToggle') {
                            clickableElements[object.name] = () => {
                                if (activeCamera === camera) {
                                    activeCamera = perspectiveCamera;
                                } else {
                                    activeCamera = camera;
                                }
                            }
                        }
                        
                        else if (object.name === 'Button_FL') {
                            clickableElements[object.name] = () => {
                                scene.getObjectByName( "Face_Frame_FL" ).position.setX(scene.getObjectByName( "Face_Frame_FL" ).position.x - 0.05);
                            }
                        }

                        else if (object.name === 'Button_Freemove') {
                            clickableElements[object.name] = () => {
                                freeMoveAllowed = true;
                            }
                        }
                        else if (object.name === 'Button_Freelook') {
                            clickableElements[object.name] = () => {
                                freeLookAllowed = true;
                                controls.lock();
                            }
                        }
                        else if (object.name === 'Button_Darkmode_FL') {
                            clickableElements[object.name] = () => {
                                darkModeEnabled = !darkModeEnabled;

                                darkModeEnableAnimation.reset();
                                darkModeDisableAnimation.reset();
                                if (darkModeEnabled) {
                                    darkModeDisableAnimation.stop();
                                    darkModeEnableAnimation.play();
                                    ambientLight.intensity = 0;
                                    spotLight.castShadow = false;
                                    spotLight.intensity = 0;
                                    pointerLantern.intensity = pointerLanternIntensity;
                                    pointerLantern.castShadow = true;

                                    scene.getObjectByName( "Toggle_Cam_Condition" ).visible = false;
                                    scene.getObjectByName( "Button_CamToggle" ).visible = true;
                                } else {
                                    darkModeEnableAnimation.stop();
                                    darkModeDisableAnimation.play();
                                    ambientLight.intensity = ambientLightIntensity;
                                    
                                    spotLight.castShadow = true;
                                    spotLight.intensity = spotLightIntensity;
                                    pointerLantern.intensity = 0;
                                    pointerLantern.castShadow = false;

                                    scene.getObjectByName( "Toggle_Cam_Condition" ).visible = true;
                                    scene.getObjectByName( "Button_CamToggle" ).visible = false;
                                }
                            }
                        }


                        // Hoverable objects
                        if (object.name === 'Aliases_text') {
                            hoverableElements[object.name] = () => {
                                const known_aliases = [
                                    ``,
                                                    
                                ];
                                object
                            }
                        }

                    });

                    eyes = scene.getObjectByName( "eyes" );
                    // const geometry = new THREE.BoxGeometry( 1, 1, 1 ); 
                    // const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} ); 
                    // const cube = new THREE.Mesh( geometry, material ); 
                    // eyes.add( cube );

                    scene.getObjectByName( "Button_CamToggle" ).visible = false;

                    objectsToReposition.forEach((object) => {
                        const parent = object.parent;
                        scene.attach( object ); // detach from parent and add to scene

                        const leftBorderOriginal = scene.getObjectByName( "Left_Border" ).position.x;
                        const rightBorderOriginal = scene.getObjectByName( "Right_Border" ).position.x;
                        const frustumSizeOriginal = rightBorderOriginal - leftBorderOriginal;

                        const originalPercentage = object.position.x / frustumSizeOriginal;

                        const leftBorderNew = frustumSize * aspect / - 2;
                        const rightBorderNew = frustumSize * aspect / 2;
                        const sizeNew = rightBorderNew - leftBorderNew;

                        object.position.setX(defaultCamPos.x + leftBorderNew + sizeNew * originalPercentage);

                        parent.attach( object );
                    });

                    objectsToAnchor.forEach((object) => {
                        camera.attach(object)
                    });


					var info = document.getElementById("info");
					info.style.display = "none";

                    renderer.setAnimationLoop( animate );
                },
                // onProgress callback: executed while loading is progressing
                function (xhr) {
                    const percentLoaded = (xhr.loaded / xhr.total * 100).toFixed(2);
					var infoPercent = document.getElementById("info-percent");
                    infoPercent.innerHTML = percentLoaded + '% loaded';
                },
                // onError callback: executed when loading errors occur
                function (error) {
					var info = document.getElementById("info");
                    info.innerHTML = "An error happened while loading the model";
                    console.error('An error happened while loading the model:', error);
                }
            );

            // --- RESPONSIVENESS ---
            const onKeyDown = function ( event ) {

                switch ( event.code ) {

                    case 'ArrowUp':
                    case 'KeyW':
                        moveForward = true;
                        break;

                    case 'ArrowLeft':
                    case 'KeyA':
                        moveLeft = true;
                        break;

                    case 'ArrowDown':
                    case 'KeyS':
                        moveBackward = true;
                        break;

                    case 'ArrowRight':
                    case 'KeyD':
                        moveRight = true;
                        break;

                    case 'Space':
                        if ( canJump === true ) velocity.y += 350;
                        canJump = false;
                        break;

                }

            };

            const onKeyUp = function ( event ) {

                switch ( event.code ) {

                    case 'ArrowUp':
                    case 'KeyW':
                        moveForward = false;
                        break;

                    case 'ArrowLeft':
                    case 'KeyA':
                        moveLeft = false;
                        break;

                    case 'ArrowDown':
                    case 'KeyS':
                        moveBackward = false;
                        break;

                    case 'ArrowRight':
                    case 'KeyD':
                        moveRight = false;
                        break;

                }

            };

            document.addEventListener( 'keydown', onKeyDown );
            document.addEventListener( 'keyup', onKeyUp );

            // Handle window resizing
            window.addEventListener('resize', () => {
                SCREEN_WIDTH = window.innerWidth;
                SCREEN_HEIGHT = window.innerHeight;
                aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
                
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

                perspectiveCamera.aspect = aspect;
				perspectiveCamera.updateProjectionMatrix();

                camera.left = - frustumSize * aspect / 2;
                camera.right = frustumSize * aspect / 2;
                camera.top = frustumSize / 2;
                camera.bottom = - frustumSize / 2;
                camera.updateProjectionMatrix();            
            });

            // Handle mouse wheel scrolling for vertical camera movement
            window.addEventListener('wheel', (event) => {
                // The event.deltaY value is positive when scrolling down and negative when scrolling up.
                // We multiply by a small factor to control the speed of the movement.
                targetCameraY -= event.deltaY * scrollSpeed;
                console.log(targetCameraY);
                targetCameraY = Math.min(maxScroll, Math.max(minScroll, targetCameraY));
            });

            
        
            window.addEventListener('click', (event) => {
                raycaster.setFromCamera( pointer, activeCamera );
                const intersects = raycaster.intersectObjects( scene.children, true );
                let top_object = null;
                for (const intersect of intersects) {
                    if (intersect !== undefined && intersect.object.visible) {
                        top_object = intersect.object;
                        break;
                    }
                }

                if (top_object && top_object.name in clickableElements) {
                    clickableElements[top_object.name]();
                }

                if (freeLookAllowed) {
                    controls.lock();
                }
            });

            document.addEventListener( 'pointermove', onPointerMove );
        }

        // --- ANIMATION LOOP ---

        // This function will be called on every frame to update the scene
        const animate = () => {
            let delta = clock.getDelta();

            if ( controls.isLocked === true && freeMoveAllowed) {
                velocity.x -= velocity.x * 3.0 * delta;
                velocity.z -= velocity.z * 3.0 * delta;

                direction.z = Number( moveForward ) - Number( moveBackward );
                direction.x = Number( moveRight ) - Number( moveLeft );
                direction.normalize(); // this ensures consistent movements in all directions

                if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
                if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;

                controls.moveRight( - velocity.x * delta );
                controls.moveForward( - velocity.z * delta );
            }

            const mousePos = new THREE.Vector3(pointer.x, pointer.y, 0.5);
            mousePos.unproject(activeCamera);

            if (darkModeEnabled) {
                pointerLantern.position.copy(mousePos);
                pointerLantern.position.setZ(camera.position.z - 2);
            }

            // Smoothly interpolate the camera's y position towards the target position
            camera.position.y += (targetCameraY - camera.position.y) * smoothingFactor;

            mixer.update( delta );

            // var eyeParent = eyes.parent;
            // scene.attach(eyes);
            // eyes.position.setX(mousePos.x);
            // eyes.position.setY(mousePos.y);
            // eyeParent.attach(eyes);
            // scene.getObjectByName("jaw_master").position.set(-100, -100, -100)

            // Render the scene from the perspective of the camera
            renderer.render(scene, activeCamera);
        };

        function onPointerMove( event ) {

            pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        }


    </script>
</body>
</html>
